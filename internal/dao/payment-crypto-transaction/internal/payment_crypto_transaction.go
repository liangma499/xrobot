// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation. 
// For more tool details, please click the link to view https://github.com/dobyte/gorm-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"fmt"
	"gorm.io/gorm"
	"strconv"
	"strings"
	modelpkg "tron_robot/internal/model"
)

type OrderBy struct {
	Column string	
	Order  string
}

type FilterFunc func(cols *Columns) any
type UpdateFunc func(cols *Columns) any
type ColumnFunc func(cols *Columns) []string
type OrderFunc func(cols *Columns) []OrderBy

type PaymentCryptoTransaction struct {
	Columns   *Columns
	Database  *gorm.DB
	Table     *gorm.DB
	TableName string
}

type Columns struct {
	ID              string // 主键
	ChannelCode     string 
	AddressKind     string 
	NetWork         string 
	TransactionHash string 
	BlockHash       string 
	BlockNum        string 
	Protocol        string 
	ToAddress       string 
	FromAddress     string 
	Amount          string 
	RealAmount      string 
	Contract        string 
	Currency        string 
	EnergyFee       string 
	NetUsage        string 
	EnergyUsage     string 
	VerifyCount     string 
	TransactionKind string 
	Stauts          string 
	CreateAt        string 
	UpdateAt        string 
}

var paymentCryptoTransactionColumns = &Columns{
	ID:              "id",               // 主键
	ChannelCode:     "channel_code",     
	AddressKind:     "address_kind",     
	NetWork:         "network",          
	TransactionHash: "transaction_hash", 
	BlockHash:       "block_hash",       
	BlockNum:        "block_num",        
	Protocol:        "protocol",         
	ToAddress:       "to_address",       
	FromAddress:     "from_address",     
	Amount:          "amount",           
	RealAmount:      "real_amount",      
	Contract:        "contract",         
	Currency:        "currency",         
	EnergyFee:       "energy_fee",       
	NetUsage:        "net_usage",        
	EnergyUsage:     "energy_usage",     
	VerifyCount:     "verify_count",     
	TransactionKind: "transaction_kind", 
	Stauts:          "stauts",           
	CreateAt:        "created_at",       
	UpdateAt:        "updated_at",       
}

func NewPaymentCryptoTransaction(db *gorm.DB) *PaymentCryptoTransaction {
	dao := &PaymentCryptoTransaction{}
	dao.Columns = paymentCryptoTransactionColumns
	dao.TableName = "payment_crypto_transaction"
	dao.Database = db
	dao.Table = db.Model(&modelpkg.PaymentCryptoTransaction{}).Table(dao.TableName)

	return dao
}

// New create a new instance and return
func (dao *PaymentCryptoTransaction) New(tx *gorm.DB) *PaymentCryptoTransaction {
	d := &PaymentCryptoTransaction{}
	d.Columns = dao.Columns
	d.TableName = dao.TableName
	d.Database = tx
	d.Table = tx.Model(&modelpkg.PaymentCryptoTransaction{}).Table(d.TableName)

	return d
}

// Insert executes an insert command to insert multiple documents into the collection.
func (dao *PaymentCryptoTransaction) Insert(ctx context.Context, models ...*modelpkg.PaymentCryptoTransaction) (int64, error) {
	if len(models) == 0 {
		return 0, errors.New("models is empty")
	}

	var rst *gorm.DB

	if len(models) == 1 {
		rst = dao.Table.WithContext(ctx).Create(models[0])
	} else {
		rst = dao.Table.WithContext(ctx).Create(models)
	}

	return rst.RowsAffected, rst.Error
}

// Delete executes a delete command to delete at most one document from the collection.
func (dao *PaymentCryptoTransaction) Delete(ctx context.Context, filterFunc ...FilterFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := db.Delete(&modelpkg.PaymentCryptoTransaction{})

	return rst.RowsAffected, rst.Error
}

// Update executes an update command to update documents in the collection.
func (dao *PaymentCryptoTransaction) Update(ctx context.Context, filterFunc FilterFunc, updateFunc UpdateFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if updateFunc != nil {
		rst := db.Updates(updateFunc(dao.Columns))

		return rst.RowsAffected, rst.Error
	}

	return 0, nil
}

// Count returns the number of documents in the collection.
func (dao *PaymentCryptoTransaction) Count(ctx context.Context, filterFunc ...FilterFunc) (count int64, err error) {
    db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	err = db.Count(&count).Error

	return
}

// Sum returns the sum of the given field.
func (dao *PaymentCryptoTransaction) Sum(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (sums []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(SUM(%s), 0) as `sum_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("sum_%d", i)]
		sum, _ := strconv.ParseFloat(val.(string), 64)
		sums = append(sums, sum)
	}

	return
}

// Avg returns the avg of the given field.
func (dao *PaymentCryptoTransaction) Avg(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (avgs []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(AVG(%s), 0) as `avg_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("avg_%d", i)]
		avg, _ := strconv.ParseFloat(val.(string), 64)
		avgs = append(avgs, avg)
	}

	return
}

// First executes a first command and returns a model for one record in the table.
func (dao *PaymentCryptoTransaction) First(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.PaymentCryptoTransaction, error) {
	var (
		model = &modelpkg.PaymentCryptoTransaction{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.First(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// Last executes a last command and returns a model for one record in the table.
func (dao *PaymentCryptoTransaction) Last(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.PaymentCryptoTransaction, error) {
	var (
		model = &modelpkg.PaymentCryptoTransaction{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Last(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindOne executes a take command and returns a model for one record in the table.
func (dao *PaymentCryptoTransaction) FindOne(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.PaymentCryptoTransaction, error) {
	var (
		model = &modelpkg.PaymentCryptoTransaction{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Take(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *PaymentCryptoTransaction) FindMany(ctx context.Context, filterFunc FilterFunc, columnFunc ColumnFunc, orderFunc OrderFunc, limitAndOffset ...int) ([]*modelpkg.PaymentCryptoTransaction, error) {
	var (
		models = make([]*modelpkg.PaymentCryptoTransaction, 0)
		db     = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if columnFunc != nil {
		columns := columnFunc(dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if orderFunc != nil {
		orders := orderFunc(dao.Columns)

		for _, order := range orders {
			db = db.Order(fmt.Sprintf("%s %s", order.Column, order.Order))
		}
	}

	if len(limitAndOffset) > 0 {
		db = db.Limit(limitAndOffset[0])
	}

	if len(limitAndOffset) > 1 {
		db = db.Offset(limitAndOffset[1])
	}

	rst := db.Scan(&models)

	if rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return models, nil
}

// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation.
// For more tool details, please click the link to view https://github.com/dobyte/gorm-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	modelpkg "xrobot/internal/model"

	"gorm.io/gorm"
)

type OrderBy struct {
	Column string
	Order  string
}

type FilterFunc func(cols *Columns) any
type UpdateFunc func(cols *Columns) any
type ColumnFunc func(cols *Columns) []string
type OrderFunc func(cols *Columns) []OrderBy

type UserBase struct {
	Columns   *Columns
	Database  *gorm.DB
	Table     *gorm.DB
	TableName string
}

type Columns struct {
	UID                   string // 主键
	Code                  string // 编号
	Account               string // 账号
	Email                 string // 邮箱
	Nickname              string // 昵称                                                                                                        // tg用户名
	Avatar                string // 头像
	LastLoginType         string // 最后登录类型
	RegisterType          string // 注册类型
	IsVerifiedEmail       string // 用户是否验证了邮箱
	Birthday              string // 生日
	UserType              string // 类型
	Status                string // 状态
	ChannelName           string // 渠道名
	ChannelCode           string // 渠道编码
	SupervisorInfo        string // 上级ID
	DeviceType            string // 设备类型(1=android、2=ios、3=web)
	DeviceID              string // 设备ID
	Language              string // 用户语言
	Country               string // 国家
	City                  string // 城市
	IsSetPasswd           string // 是设置过密码
	TotalLoginTimes       string // 总共登录次数
	TotalLoginDays        string // 总共登录天数
	ContinuouslyLoginDays string // 连续登录天数
	LastLoginZero         string // 上次登录时间
	LastLoginAt           string // 上次登录时间
	LastLoginIP           string
	RegisterZero          string
	RegisterIP            string // 注册IP
	RegisterAt            string // 注册时间
}

var userBaseColumns = &Columns{
	UID:                   "uid",                     // 主键
	Code:                  "code",                    // 编号
	Account:               "account",                 // 账号
	Email:                 "email",                   // 邮箱
	Nickname:              "nickname",                // 昵称                                                                                                        // tg用户名
	Avatar:                "avatar",                  // 头像
	LastLoginType:         "last_login_type",         // 最后登录类型
	RegisterType:          "register_type",           // 注册类型
	IsVerifiedEmail:       "is_verified_email",       // 用户是否验证了邮箱
	Birthday:              "birthday",                // 生日
	UserType:              "user_type",               // 类型
	Status:                "status",                  // 状态
	ChannelName:           "channel_name",            // 渠道名
	ChannelCode:           "channel_code",            // 渠道编码
	SupervisorInfo:        "supervisor_info",         // 上级ID
	DeviceType:            "device_type",             // 设备类型(1=android、2=ios、3=web)
	DeviceID:              "device_id",               // 设备ID
	Language:              "language",                // 用户语言
	Country:               "country",                 // 国家
	City:                  "city",                    // 城市
	IsSetPasswd:           "is_set_passwd",           // 是设置过密码
	TotalLoginTimes:       "total_login_times",       // 总共登录次数
	TotalLoginDays:        "total_login_days",        // 总共登录天数
	ContinuouslyLoginDays: "continuously_login_days", // 连续登录天数
	LastLoginZero:         "last_login_zero",         // 上次登录时间
	LastLoginAt:           "last_login_at",           // 上次登录时间
	LastLoginIP:           "last_login_ip",
	RegisterZero:          "register_zero",
	RegisterIP:            "register_ip", // 注册IP
	RegisterAt:            "register_at", // 注册时间
}

func NewUserBase(db *gorm.DB) *UserBase {
	dao := &UserBase{}
	dao.Columns = userBaseColumns
	dao.TableName = "user_base"
	dao.Database = db
	dao.Table = db.Model(&modelpkg.UserBase{}).Table(dao.TableName)

	return dao
}

// New create a new instance and return
func (dao *UserBase) New(tx *gorm.DB) *UserBase {
	d := &UserBase{}
	d.Columns = dao.Columns
	d.TableName = dao.TableName
	d.Database = tx
	d.Table = tx.Model(&modelpkg.UserBase{}).Table(d.TableName)

	return d
}

// Insert executes an insert command to insert multiple documents into the collection.
func (dao *UserBase) Insert(ctx context.Context, models ...*modelpkg.UserBase) (int64, error) {
	if len(models) == 0 {
		return 0, errors.New("models is empty")
	}

	var rst *gorm.DB

	if len(models) == 1 {
		rst = dao.Table.WithContext(ctx).Create(models[0])
	} else {
		rst = dao.Table.WithContext(ctx).Create(models)
	}

	return rst.RowsAffected, rst.Error
}

// Delete executes a delete command to delete at most one document from the collection.
func (dao *UserBase) Delete(ctx context.Context, filterFunc ...FilterFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := db.Delete(&modelpkg.UserBase{})

	return rst.RowsAffected, rst.Error
}

// Update executes an update command to update documents in the collection.
func (dao *UserBase) Update(ctx context.Context, filterFunc FilterFunc, updateFunc UpdateFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if updateFunc != nil {
		rst := db.Updates(updateFunc(dao.Columns))

		return rst.RowsAffected, rst.Error
	}

	return 0, nil
}

// Count returns the number of documents in the collection.
func (dao *UserBase) Count(ctx context.Context, filterFunc ...FilterFunc) (count int64, err error) {
	db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	err = db.Count(&count).Error

	return
}

// Sum returns the sum of the given field.
func (dao *UserBase) Sum(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (sums []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(SUM(%s), 0) as `sum_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("sum_%d", i)]
		sum, _ := strconv.ParseFloat(val.(string), 64)
		sums = append(sums, sum)
	}

	return
}

// Avg returns the avg of the given field.
func (dao *UserBase) Avg(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (avgs []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(AVG(%s), 0) as `avg_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("avg_%d", i)]
		avg, _ := strconv.ParseFloat(val.(string), 64)
		avgs = append(avgs, avg)
	}

	return
}

// First executes a first command and returns a model for one record in the table.
func (dao *UserBase) First(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.UserBase, error) {
	var (
		model = &modelpkg.UserBase{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.First(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// Last executes a last command and returns a model for one record in the table.
func (dao *UserBase) Last(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.UserBase, error) {
	var (
		model = &modelpkg.UserBase{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Last(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindOne executes a take command and returns a model for one record in the table.
func (dao *UserBase) FindOne(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.UserBase, error) {
	var (
		model = &modelpkg.UserBase{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Take(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *UserBase) FindMany(ctx context.Context, filterFunc FilterFunc, columnFunc ColumnFunc, orderFunc OrderFunc, limitAndOffset ...int) ([]*modelpkg.UserBase, error) {
	var (
		models = make([]*modelpkg.UserBase, 0)
		db     = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if columnFunc != nil {
		columns := columnFunc(dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if orderFunc != nil {
		orders := orderFunc(dao.Columns)

		for _, order := range orders {
			db = db.Order(fmt.Sprintf("%s %s", order.Column, order.Order))
		}
	}

	if len(limitAndOffset) > 0 {
		db = db.Limit(limitAndOffset[0])
	}

	if len(limitAndOffset) > 1 {
		db = db.Offset(limitAndOffset[1])
	}

	rst := db.Scan(&models)

	if rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return models, nil
}

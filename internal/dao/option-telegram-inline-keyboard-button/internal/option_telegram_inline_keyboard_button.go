// --------------------------------------------------------------------------------------------
// The following code is automatically generated by the mongo-dao-generator tool.
// Please do not modify this code manually to avoid being overwritten in the next generation. 
// For more tool details, please click the link to view https://github.com/dobyte/gorm-dao-generator
// --------------------------------------------------------------------------------------------

package internal

import (
	"context"
	"errors"
	"fmt"
	"gorm.io/gorm"
	"strconv"
	"strings"
	modelpkg "tron_robot/internal/model"
)

type OrderBy struct {
	Column string	
	Order  string
}

type FilterFunc func(cols *Columns) any
type UpdateFunc func(cols *Columns) any
type ColumnFunc func(cols *Columns) []string
type OrderFunc func(cols *Columns) []OrderBy

type OptionTelegramInlineKeyboardButton struct {
	Columns   *Columns
	Database  *gorm.DB
	Table     *gorm.DB
	TableName string
}

type Columns struct {
	ChannelCode                  string //渠道code
	Cmd                          string //推送方式                                                                        // 主键
	Name                         string // Label text on the button
	LineID                       string //按钮所在行
	Sort                         string //按钮所在列
	Kind                         string //(1=跳转网页，2=跳转应用)
	URL                          string // 自选。按下按钮时要打开的 HTTP 或 tg:// URL。如果其隐私设置允许，则链接 tg：//user？id=<user_id> 可用于通过用户的 ID 提及用户，而无需使用用户名。
	CallbackData                 string // 自选。用户按下按钮时将启动的 Web 应用程序的描述。Web 应用程序将能够使用 answerWebAppQuery 方法代表用户发送任意消息。仅在用户与 bot 之间的私人聊天中可用。
	LoginURL                     string // 自选。按下按钮时要在回调查询中发送到机器人的数据，1-64 字节
	SwitchInlineQuery            string // 自选。如果设置，按下该按钮将提示用户选择他们的一个聊天，打开该聊天并在输入字段中插入机器人的用户名和指定的内联查询。可能为空，在这种情况下，只会插入机器人的用户名。注意：这为用户提供了一种简单的方法，当他们当前正在与您的机器人进行私人聊天时，他们可以在内联模式下开始使用您的机器人。与 switch_pm 结合使用时特别有用...操作 - 在这种情况下，用户将自动返回到他们切换的聊天，跳过聊天选择屏幕。
	SwitchInlineQueryCurrentChat string // 自选。如果设置，按下该按钮将在当前聊天的输入字段中插入机器人的用户名和指定的内联查询。可能为空，在这种情况下，只会插入机器人的用户名。这为用户提供了一种在同一聊天中以内联模式打开机器人的快速方法 - 非常适合从多个选项中选择内容。
	SwitchInlineQueryChosenChat  string // 自选。如果设置，按下该按钮将提示用户选择指定类型的聊天之一，打开该聊天并在输入字段中插入机器人的用户名和指定的内联查询。
	Pay                          string // 自选。指定 True，以发送 Pay 按钮。注意： 这种类型的按钮必须始终是第一行的第一个按钮，并且只能在发票消息中使用。
	IsXtelegramToken             string 
	Status                       string 
	OperateUid                   string //
	OperateUser                  string //
	CreateAt                     string //
	UpdateAt                     string //
}

var optionTelegramInlineKeyboardButtonColumns = &Columns{
	ChannelCode:                  "channel_code",                     //渠道code
	Cmd:                          "cmd",                              //推送方式                                                                        // 主键
	Name:                         "name",                             // Label text on the button
	LineID:                       "line_id",                          //按钮所在行
	Sort:                         "sort",                             //按钮所在列
	Kind:                         "kind",                             //(1=跳转网页，2=跳转应用)
	URL:                          "url",                              // 自选。按下按钮时要打开的 HTTP 或 tg:// URL。如果其隐私设置允许，则链接 tg：//user？id=<user_id> 可用于通过用户的 ID 提及用户，而无需使用用户名。
	CallbackData:                 "callback_data",                    // 自选。用户按下按钮时将启动的 Web 应用程序的描述。Web 应用程序将能够使用 answerWebAppQuery 方法代表用户发送任意消息。仅在用户与 bot 之间的私人聊天中可用。
	LoginURL:                     "login_url",                        // 自选。按下按钮时要在回调查询中发送到机器人的数据，1-64 字节
	SwitchInlineQuery:            "switch_inline_query",              // 自选。如果设置，按下该按钮将提示用户选择他们的一个聊天，打开该聊天并在输入字段中插入机器人的用户名和指定的内联查询。可能为空，在这种情况下，只会插入机器人的用户名。注意：这为用户提供了一种简单的方法，当他们当前正在与您的机器人进行私人聊天时，他们可以在内联模式下开始使用您的机器人。与 switch_pm 结合使用时特别有用...操作 - 在这种情况下，用户将自动返回到他们切换的聊天，跳过聊天选择屏幕。
	SwitchInlineQueryCurrentChat: "switch_inline_query_current_chat", // 自选。如果设置，按下该按钮将在当前聊天的输入字段中插入机器人的用户名和指定的内联查询。可能为空，在这种情况下，只会插入机器人的用户名。这为用户提供了一种在同一聊天中以内联模式打开机器人的快速方法 - 非常适合从多个选项中选择内容。
	SwitchInlineQueryChosenChat:  "switch_inline_query_chosen_chat",  // 自选。如果设置，按下该按钮将提示用户选择指定类型的聊天之一，打开该聊天并在输入字段中插入机器人的用户名和指定的内联查询。
	Pay:                          "pay",                              // 自选。指定 True，以发送 Pay 按钮。注意： 这种类型的按钮必须始终是第一行的第一个按钮，并且只能在发票消息中使用。
	IsXtelegramToken:             "is_xtelegram_token",               
	Status:                       "status",                           
	OperateUid:                   "operate_uid",                      //
	OperateUser:                  "operate_user",                     //
	CreateAt:                     "created_at",                       //
	UpdateAt:                     "updated_at",                       //
}

func NewOptionTelegramInlineKeyboardButton(db *gorm.DB) *OptionTelegramInlineKeyboardButton {
	dao := &OptionTelegramInlineKeyboardButton{}
	dao.Columns = optionTelegramInlineKeyboardButtonColumns
	dao.TableName = "option_telegram_inline_keyboard_button"
	dao.Database = db
	dao.Table = db.Model(&modelpkg.OptionTelegramInlineKeyboardButton{}).Table(dao.TableName)

	return dao
}

// New create a new instance and return
func (dao *OptionTelegramInlineKeyboardButton) New(tx *gorm.DB) *OptionTelegramInlineKeyboardButton {
	d := &OptionTelegramInlineKeyboardButton{}
	d.Columns = dao.Columns
	d.TableName = dao.TableName
	d.Database = tx
	d.Table = tx.Model(&modelpkg.OptionTelegramInlineKeyboardButton{}).Table(d.TableName)

	return d
}

// Insert executes an insert command to insert multiple documents into the collection.
func (dao *OptionTelegramInlineKeyboardButton) Insert(ctx context.Context, models ...*modelpkg.OptionTelegramInlineKeyboardButton) (int64, error) {
	if len(models) == 0 {
		return 0, errors.New("models is empty")
	}

	var rst *gorm.DB

	if len(models) == 1 {
		rst = dao.Table.WithContext(ctx).Create(models[0])
	} else {
		rst = dao.Table.WithContext(ctx).Create(models)
	}

	return rst.RowsAffected, rst.Error
}

// Delete executes a delete command to delete at most one document from the collection.
func (dao *OptionTelegramInlineKeyboardButton) Delete(ctx context.Context, filterFunc ...FilterFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := db.Delete(&modelpkg.OptionTelegramInlineKeyboardButton{})

	return rst.RowsAffected, rst.Error
}

// Update executes an update command to update documents in the collection.
func (dao *OptionTelegramInlineKeyboardButton) Update(ctx context.Context, filterFunc FilterFunc, updateFunc UpdateFunc) (int64, error) {
	db := dao.Table.WithContext(ctx)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if updateFunc != nil {
		rst := db.Updates(updateFunc(dao.Columns))

		return rst.RowsAffected, rst.Error
	}

	return 0, nil
}

// Count returns the number of documents in the collection.
func (dao *OptionTelegramInlineKeyboardButton) Count(ctx context.Context, filterFunc ...FilterFunc) (count int64, err error) {
    db := dao.Table.WithContext(ctx)

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	err = db.Count(&count).Error

	return
}

// Sum returns the sum of the given field.
func (dao *OptionTelegramInlineKeyboardButton) Sum(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (sums []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(SUM(%s), 0) as `sum_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("sum_%d", i)]
		sum, _ := strconv.ParseFloat(val.(string), 64)
		sums = append(sums, sum)
	}

	return
}

// Avg returns the avg of the given field.
func (dao *OptionTelegramInlineKeyboardButton) Avg(ctx context.Context, columnFunc ColumnFunc, filterFunc ...FilterFunc) (avgs []float64, err error) {
	columns := columnFunc(dao.Columns)
	if len(columns) == 0 {
		return
	}

	fields := make([]string, len(columns))
	for i, column := range columns {
		fields[i] = fmt.Sprintf("COALESCE(AVG(%s), 0) as `avg_%d`", column, i)
	}

	db := dao.Table.WithContext(ctx).Select(strings.Join(fields, ","))

	if len(filterFunc) > 0 && filterFunc[0] != nil {
		db = db.Where(filterFunc[0](dao.Columns))
	}

	rst := make(map[string]any, len(columns))

	if err = db.Scan(&rst).Error; err != nil {
		return
	}

	for i := range columns {
		val, _ := rst[fmt.Sprintf("avg_%d", i)]
		avg, _ := strconv.ParseFloat(val.(string), 64)
		avgs = append(avgs, avg)
	}

	return
}

// First executes a first command and returns a model for one record in the table.
func (dao *OptionTelegramInlineKeyboardButton) First(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.OptionTelegramInlineKeyboardButton, error) {
	var (
		model = &modelpkg.OptionTelegramInlineKeyboardButton{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.First(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// Last executes a last command and returns a model for one record in the table.
func (dao *OptionTelegramInlineKeyboardButton) Last(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.OptionTelegramInlineKeyboardButton, error) {
	var (
		model = &modelpkg.OptionTelegramInlineKeyboardButton{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Last(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindOne executes a take command and returns a model for one record in the table.
func (dao *OptionTelegramInlineKeyboardButton) FindOne(ctx context.Context, filterFunc FilterFunc, columnFunc ...ColumnFunc) (*modelpkg.OptionTelegramInlineKeyboardButton, error) {
	var (
		model = &modelpkg.OptionTelegramInlineKeyboardButton{}
		db    = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if len(columnFunc) > 0 && columnFunc[0] != nil {
		columns := columnFunc[0](dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if rst := db.Take(model); rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return model, nil
}

// FindMany executes a find command and returns many models the matching documents in the collection.
func (dao *OptionTelegramInlineKeyboardButton) FindMany(ctx context.Context, filterFunc FilterFunc, columnFunc ColumnFunc, orderFunc OrderFunc, limitAndOffset ...int) ([]*modelpkg.OptionTelegramInlineKeyboardButton, error) {
	var (
		models = make([]*modelpkg.OptionTelegramInlineKeyboardButton, 0)
		db     = dao.Table.WithContext(ctx)
	)

	if filterFunc != nil {
		db = db.Where(filterFunc(dao.Columns))
	}

	if columnFunc != nil {
		columns := columnFunc(dao.Columns)

		if len(columns) > 0 {
			db = db.Select(columns)
		}
	}

	if orderFunc != nil {
		orders := orderFunc(dao.Columns)

		for _, order := range orders {
			db = db.Order(fmt.Sprintf("%s %s", order.Column, order.Order))
		}
	}

	if len(limitAndOffset) > 0 {
		db = db.Limit(limitAndOffset[0])
	}

	if len(limitAndOffset) > 1 {
		db = db.Offset(limitAndOffset[1])
	}

	rst := db.Scan(&models)

	if rst.Error != nil {
		if errors.Is(rst.Error, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, rst.Error
	}

	return models, nil
}

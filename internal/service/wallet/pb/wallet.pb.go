// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: wallet.proto

package pb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type InitWalletArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	DefaultCurrency      string   `protobuf:"bytes,2,opt,name=DefaultCurrency,proto3" json:"DefaultCurrency,omitempty"`
	InitCash             float64  `protobuf:"fixed64,3,opt,name=InitCash,proto3" json:"InitCash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletArgs) Reset()         { *m = InitWalletArgs{} }
func (m *InitWalletArgs) String() string { return proto.CompactTextString(m) }
func (*InitWalletArgs) ProtoMessage()    {}
func (*InitWalletArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{0}
}
func (m *InitWalletArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitWalletArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitWalletArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitWalletArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletArgs.Merge(m, src)
}
func (m *InitWalletArgs) XXX_Size() int {
	return m.Size()
}
func (m *InitWalletArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletArgs.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletArgs proto.InternalMessageInfo

func (m *InitWalletArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *InitWalletArgs) GetDefaultCurrency() string {
	if m != nil {
		return m.DefaultCurrency
	}
	return ""
}

func (m *InitWalletArgs) GetInitCash() float64 {
	if m != nil {
		return m.InitCash
	}
	return 0
}

type InitWalletReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitWalletReply) Reset()         { *m = InitWalletReply{} }
func (m *InitWalletReply) String() string { return proto.CompactTextString(m) }
func (*InitWalletReply) ProtoMessage()    {}
func (*InitWalletReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{1}
}
func (m *InitWalletReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitWalletReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitWalletReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitWalletReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitWalletReply.Merge(m, src)
}
func (m *InitWalletReply) XXX_Size() int {
	return m.Size()
}
func (m *InitWalletReply) XXX_DiscardUnknown() {
	xxx_messageInfo_InitWalletReply.DiscardUnknown(m)
}

var xxx_messageInfo_InitWalletReply proto.InternalMessageInfo

type SetDefaultCurrencyArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,2,opt,name=Currency,proto3" json:"Currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetDefaultCurrencyArgs) Reset()         { *m = SetDefaultCurrencyArgs{} }
func (m *SetDefaultCurrencyArgs) String() string { return proto.CompactTextString(m) }
func (*SetDefaultCurrencyArgs) ProtoMessage()    {}
func (*SetDefaultCurrencyArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{2}
}
func (m *SetDefaultCurrencyArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDefaultCurrencyArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDefaultCurrencyArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDefaultCurrencyArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDefaultCurrencyArgs.Merge(m, src)
}
func (m *SetDefaultCurrencyArgs) XXX_Size() int {
	return m.Size()
}
func (m *SetDefaultCurrencyArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDefaultCurrencyArgs.DiscardUnknown(m)
}

var xxx_messageInfo_SetDefaultCurrencyArgs proto.InternalMessageInfo

func (m *SetDefaultCurrencyArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *SetDefaultCurrencyArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type SetDefaultCurrencyReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetDefaultCurrencyReply) Reset()         { *m = SetDefaultCurrencyReply{} }
func (m *SetDefaultCurrencyReply) String() string { return proto.CompactTextString(m) }
func (*SetDefaultCurrencyReply) ProtoMessage()    {}
func (*SetDefaultCurrencyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{3}
}
func (m *SetDefaultCurrencyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDefaultCurrencyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDefaultCurrencyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetDefaultCurrencyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDefaultCurrencyReply.Merge(m, src)
}
func (m *SetDefaultCurrencyReply) XXX_Size() int {
	return m.Size()
}
func (m *SetDefaultCurrencyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDefaultCurrencyReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetDefaultCurrencyReply proto.InternalMessageInfo

type IncrBalanceArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,2,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Cash                 float64  `protobuf:"fixed64,3,opt,name=Cash,proto3" json:"Cash,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RelatedID            string   `protobuf:"bytes,7,opt,name=RelatedID,proto3" json:"RelatedID,omitempty"`
	Taxation             float64  `protobuf:"fixed64,8,opt,name=Taxation,proto3" json:"Taxation,omitempty"`
	BetAmount            float64  `protobuf:"fixed64,9,opt,name=BetAmount,proto3" json:"BetAmount,omitempty"`
	Rebate               bool     `protobuf:"varint,10,opt,name=Rebate,proto3" json:"Rebate,omitempty"`
	GameName             string   `protobuf:"bytes,11,opt,name=GameName,proto3" json:"GameName,omitempty"`
	AmountKind           int32    `protobuf:"varint,12,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	PlayCurrencyID       int64    `protobuf:"varint,13,opt,name=PlayCurrencyID,proto3" json:"PlayCurrencyID,omitempty"`
	PlayCurrency         string   `protobuf:"bytes,14,opt,name=PlayCurrency,proto3" json:"PlayCurrency,omitempty"`
	PlayCash             float64  `protobuf:"fixed64,15,opt,name=PlayCash,proto3" json:"PlayCash,omitempty"`
	TransactionID        string   `protobuf:"bytes,16,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	UserControlKind      int32    `protobuf:"varint,17,opt,name=UserControlKind,proto3" json:"UserControlKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IncrBalanceArgs) Reset()         { *m = IncrBalanceArgs{} }
func (m *IncrBalanceArgs) String() string { return proto.CompactTextString(m) }
func (*IncrBalanceArgs) ProtoMessage()    {}
func (*IncrBalanceArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{4}
}
func (m *IncrBalanceArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrBalanceArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrBalanceArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrBalanceArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrBalanceArgs.Merge(m, src)
}
func (m *IncrBalanceArgs) XXX_Size() int {
	return m.Size()
}
func (m *IncrBalanceArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrBalanceArgs.DiscardUnknown(m)
}

var xxx_messageInfo_IncrBalanceArgs proto.InternalMessageInfo

func (m *IncrBalanceArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *IncrBalanceArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *IncrBalanceArgs) GetCash() float64 {
	if m != nil {
		return m.Cash
	}
	return 0
}

func (m *IncrBalanceArgs) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *IncrBalanceArgs) GetRelatedID() string {
	if m != nil {
		return m.RelatedID
	}
	return ""
}

func (m *IncrBalanceArgs) GetTaxation() float64 {
	if m != nil {
		return m.Taxation
	}
	return 0
}

func (m *IncrBalanceArgs) GetBetAmount() float64 {
	if m != nil {
		return m.BetAmount
	}
	return 0
}

func (m *IncrBalanceArgs) GetRebate() bool {
	if m != nil {
		return m.Rebate
	}
	return false
}

func (m *IncrBalanceArgs) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *IncrBalanceArgs) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

func (m *IncrBalanceArgs) GetPlayCurrencyID() int64 {
	if m != nil {
		return m.PlayCurrencyID
	}
	return 0
}

func (m *IncrBalanceArgs) GetPlayCurrency() string {
	if m != nil {
		return m.PlayCurrency
	}
	return ""
}

func (m *IncrBalanceArgs) GetPlayCash() float64 {
	if m != nil {
		return m.PlayCash
	}
	return 0
}

func (m *IncrBalanceArgs) GetTransactionID() string {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *IncrBalanceArgs) GetUserControlKind() int32 {
	if m != nil {
		return m.UserControlKind
	}
	return 0
}

type IncrBalanceReply struct {
	TradeNO              string       `protobuf:"bytes,1,opt,name=TradeNO,proto3" json:"TradeNO,omitempty"`
	Balance              *BalanceInfo `protobuf:"bytes,2,opt,name=Balance,proto3" json:"Balance,omitempty"`
	Change               *ChangeInfo  `protobuf:"bytes,3,opt,name=Change,proto3" json:"Change,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IncrBalanceReply) Reset()         { *m = IncrBalanceReply{} }
func (m *IncrBalanceReply) String() string { return proto.CompactTextString(m) }
func (*IncrBalanceReply) ProtoMessage()    {}
func (*IncrBalanceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{5}
}
func (m *IncrBalanceReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IncrBalanceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IncrBalanceReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IncrBalanceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IncrBalanceReply.Merge(m, src)
}
func (m *IncrBalanceReply) XXX_Size() int {
	return m.Size()
}
func (m *IncrBalanceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_IncrBalanceReply.DiscardUnknown(m)
}

var xxx_messageInfo_IncrBalanceReply proto.InternalMessageInfo

func (m *IncrBalanceReply) GetTradeNO() string {
	if m != nil {
		return m.TradeNO
	}
	return ""
}

func (m *IncrBalanceReply) GetBalance() *BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *IncrBalanceReply) GetChange() *ChangeInfo {
	if m != nil {
		return m.Change
	}
	return nil
}

type DecrBalanceArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,2,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Cash                 float64  `protobuf:"fixed64,3,opt,name=Cash,proto3" json:"Cash,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=Type,proto3" json:"Type,omitempty"`
	RelatedID            string   `protobuf:"bytes,7,opt,name=RelatedID,proto3" json:"RelatedID,omitempty"`
	Taxation             float64  `protobuf:"fixed64,8,opt,name=Taxation,proto3" json:"Taxation,omitempty"`
	BetAmount            float64  `protobuf:"fixed64,9,opt,name=BetAmount,proto3" json:"BetAmount,omitempty"`
	Rebate               bool     `protobuf:"varint,10,opt,name=Rebate,proto3" json:"Rebate,omitempty"`
	GameName             string   `protobuf:"bytes,11,opt,name=GameName,proto3" json:"GameName,omitempty"`
	AmountKind           int32    `protobuf:"varint,12,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	PlayCurrencyID       int64    `protobuf:"varint,13,opt,name=PlayCurrencyID,proto3" json:"PlayCurrencyID,omitempty"`
	PlayCurrency         string   `protobuf:"bytes,14,opt,name=PlayCurrency,proto3" json:"PlayCurrency,omitempty"`
	PlayCash             float64  `protobuf:"fixed64,15,opt,name=PlayCash,proto3" json:"PlayCash,omitempty"`
	TransactionID        string   `protobuf:"bytes,16,opt,name=TransactionID,proto3" json:"TransactionID,omitempty"`
	UserControlKind      int32    `protobuf:"varint,17,opt,name=UserControlKind,proto3" json:"UserControlKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecrBalanceArgs) Reset()         { *m = DecrBalanceArgs{} }
func (m *DecrBalanceArgs) String() string { return proto.CompactTextString(m) }
func (*DecrBalanceArgs) ProtoMessage()    {}
func (*DecrBalanceArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{6}
}
func (m *DecrBalanceArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecrBalanceArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecrBalanceArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecrBalanceArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecrBalanceArgs.Merge(m, src)
}
func (m *DecrBalanceArgs) XXX_Size() int {
	return m.Size()
}
func (m *DecrBalanceArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_DecrBalanceArgs.DiscardUnknown(m)
}

var xxx_messageInfo_DecrBalanceArgs proto.InternalMessageInfo

func (m *DecrBalanceArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *DecrBalanceArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *DecrBalanceArgs) GetCash() float64 {
	if m != nil {
		return m.Cash
	}
	return 0
}

func (m *DecrBalanceArgs) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DecrBalanceArgs) GetRelatedID() string {
	if m != nil {
		return m.RelatedID
	}
	return ""
}

func (m *DecrBalanceArgs) GetTaxation() float64 {
	if m != nil {
		return m.Taxation
	}
	return 0
}

func (m *DecrBalanceArgs) GetBetAmount() float64 {
	if m != nil {
		return m.BetAmount
	}
	return 0
}

func (m *DecrBalanceArgs) GetRebate() bool {
	if m != nil {
		return m.Rebate
	}
	return false
}

func (m *DecrBalanceArgs) GetGameName() string {
	if m != nil {
		return m.GameName
	}
	return ""
}

func (m *DecrBalanceArgs) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

func (m *DecrBalanceArgs) GetPlayCurrencyID() int64 {
	if m != nil {
		return m.PlayCurrencyID
	}
	return 0
}

func (m *DecrBalanceArgs) GetPlayCurrency() string {
	if m != nil {
		return m.PlayCurrency
	}
	return ""
}

func (m *DecrBalanceArgs) GetPlayCash() float64 {
	if m != nil {
		return m.PlayCash
	}
	return 0
}

func (m *DecrBalanceArgs) GetTransactionID() string {
	if m != nil {
		return m.TransactionID
	}
	return ""
}

func (m *DecrBalanceArgs) GetUserControlKind() int32 {
	if m != nil {
		return m.UserControlKind
	}
	return 0
}

type DecrBalanceReply struct {
	TradeNO              string       `protobuf:"bytes,1,opt,name=TradeNO,proto3" json:"TradeNO,omitempty"`
	Balance              *BalanceInfo `protobuf:"bytes,2,opt,name=Balance,proto3" json:"Balance,omitempty"`
	Change               *ChangeInfo  `protobuf:"bytes,3,opt,name=Change,proto3" json:"Change,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *DecrBalanceReply) Reset()         { *m = DecrBalanceReply{} }
func (m *DecrBalanceReply) String() string { return proto.CompactTextString(m) }
func (*DecrBalanceReply) ProtoMessage()    {}
func (*DecrBalanceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{7}
}
func (m *DecrBalanceReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecrBalanceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecrBalanceReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecrBalanceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecrBalanceReply.Merge(m, src)
}
func (m *DecrBalanceReply) XXX_Size() int {
	return m.Size()
}
func (m *DecrBalanceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_DecrBalanceReply.DiscardUnknown(m)
}

var xxx_messageInfo_DecrBalanceReply proto.InternalMessageInfo

func (m *DecrBalanceReply) GetTradeNO() string {
	if m != nil {
		return m.TradeNO
	}
	return ""
}

func (m *DecrBalanceReply) GetBalance() *BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *DecrBalanceReply) GetChange() *ChangeInfo {
	if m != nil {
		return m.Change
	}
	return nil
}

type FreezeBalanceArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,2,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Cash                 float64  `protobuf:"fixed64,3,opt,name=Cash,proto3" json:"Cash,omitempty"`
	Amount               float64  `protobuf:"fixed64,5,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Type                 int32    `protobuf:"varint,6,opt,name=Type,proto3" json:"Type,omitempty"`
	RelatedID            string   `protobuf:"bytes,9,opt,name=RelatedID,proto3" json:"RelatedID,omitempty"`
	Rebate               bool     `protobuf:"varint,10,opt,name=Rebate,proto3" json:"Rebate,omitempty"`
	AmountKind           int32    `protobuf:"varint,11,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FreezeBalanceArgs) Reset()         { *m = FreezeBalanceArgs{} }
func (m *FreezeBalanceArgs) String() string { return proto.CompactTextString(m) }
func (*FreezeBalanceArgs) ProtoMessage()    {}
func (*FreezeBalanceArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{8}
}
func (m *FreezeBalanceArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FreezeBalanceArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FreezeBalanceArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FreezeBalanceArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FreezeBalanceArgs.Merge(m, src)
}
func (m *FreezeBalanceArgs) XXX_Size() int {
	return m.Size()
}
func (m *FreezeBalanceArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_FreezeBalanceArgs.DiscardUnknown(m)
}

var xxx_messageInfo_FreezeBalanceArgs proto.InternalMessageInfo

func (m *FreezeBalanceArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *FreezeBalanceArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *FreezeBalanceArgs) GetCash() float64 {
	if m != nil {
		return m.Cash
	}
	return 0
}

func (m *FreezeBalanceArgs) GetAmount() float64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *FreezeBalanceArgs) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FreezeBalanceArgs) GetRelatedID() string {
	if m != nil {
		return m.RelatedID
	}
	return ""
}

func (m *FreezeBalanceArgs) GetRebate() bool {
	if m != nil {
		return m.Rebate
	}
	return false
}

func (m *FreezeBalanceArgs) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

type FreezeBalanceReply struct {
	TradeNO              string       `protobuf:"bytes,1,opt,name=TradeNO,proto3" json:"TradeNO,omitempty"`
	Balance              *BalanceInfo `protobuf:"bytes,2,opt,name=Balance,proto3" json:"Balance,omitempty"`
	Change               *ChangeInfo  `protobuf:"bytes,3,opt,name=Change,proto3" json:"Change,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FreezeBalanceReply) Reset()         { *m = FreezeBalanceReply{} }
func (m *FreezeBalanceReply) String() string { return proto.CompactTextString(m) }
func (*FreezeBalanceReply) ProtoMessage()    {}
func (*FreezeBalanceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{9}
}
func (m *FreezeBalanceReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FreezeBalanceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FreezeBalanceReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FreezeBalanceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FreezeBalanceReply.Merge(m, src)
}
func (m *FreezeBalanceReply) XXX_Size() int {
	return m.Size()
}
func (m *FreezeBalanceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FreezeBalanceReply.DiscardUnknown(m)
}

var xxx_messageInfo_FreezeBalanceReply proto.InternalMessageInfo

func (m *FreezeBalanceReply) GetTradeNO() string {
	if m != nil {
		return m.TradeNO
	}
	return ""
}

func (m *FreezeBalanceReply) GetBalance() *BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *FreezeBalanceReply) GetChange() *ChangeInfo {
	if m != nil {
		return m.Change
	}
	return nil
}

type CancelTradeArgs struct {
	TradeNO              string   `protobuf:"bytes,1,opt,name=TradeNO,proto3" json:"TradeNO,omitempty"`
	RelatedID            string   `protobuf:"bytes,4,opt,name=RelatedID,proto3" json:"RelatedID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelTradeArgs) Reset()         { *m = CancelTradeArgs{} }
func (m *CancelTradeArgs) String() string { return proto.CompactTextString(m) }
func (*CancelTradeArgs) ProtoMessage()    {}
func (*CancelTradeArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{10}
}
func (m *CancelTradeArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelTradeArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelTradeArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelTradeArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelTradeArgs.Merge(m, src)
}
func (m *CancelTradeArgs) XXX_Size() int {
	return m.Size()
}
func (m *CancelTradeArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelTradeArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CancelTradeArgs proto.InternalMessageInfo

func (m *CancelTradeArgs) GetTradeNO() string {
	if m != nil {
		return m.TradeNO
	}
	return ""
}

func (m *CancelTradeArgs) GetRelatedID() string {
	if m != nil {
		return m.RelatedID
	}
	return ""
}

type CancelTradeReply struct {
	Balance              *BalanceInfo `protobuf:"bytes,1,opt,name=Balance,proto3" json:"Balance,omitempty"`
	Change               *ChangeInfo  `protobuf:"bytes,2,opt,name=Change,proto3" json:"Change,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CancelTradeReply) Reset()         { *m = CancelTradeReply{} }
func (m *CancelTradeReply) String() string { return proto.CompactTextString(m) }
func (*CancelTradeReply) ProtoMessage()    {}
func (*CancelTradeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{11}
}
func (m *CancelTradeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelTradeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelTradeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelTradeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelTradeReply.Merge(m, src)
}
func (m *CancelTradeReply) XXX_Size() int {
	return m.Size()
}
func (m *CancelTradeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelTradeReply.DiscardUnknown(m)
}

var xxx_messageInfo_CancelTradeReply proto.InternalMessageInfo

func (m *CancelTradeReply) GetBalance() *BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *CancelTradeReply) GetChange() *ChangeInfo {
	if m != nil {
		return m.Change
	}
	return nil
}

type CompleteTradeArgs struct {
	TradeNO              string   `protobuf:"bytes,1,opt,name=TradeNO,proto3" json:"TradeNO,omitempty"`
	RelatedID            string   `protobuf:"bytes,4,opt,name=RelatedID,proto3" json:"RelatedID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteTradeArgs) Reset()         { *m = CompleteTradeArgs{} }
func (m *CompleteTradeArgs) String() string { return proto.CompactTextString(m) }
func (*CompleteTradeArgs) ProtoMessage()    {}
func (*CompleteTradeArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{12}
}
func (m *CompleteTradeArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteTradeArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteTradeArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteTradeArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteTradeArgs.Merge(m, src)
}
func (m *CompleteTradeArgs) XXX_Size() int {
	return m.Size()
}
func (m *CompleteTradeArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteTradeArgs.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteTradeArgs proto.InternalMessageInfo

func (m *CompleteTradeArgs) GetTradeNO() string {
	if m != nil {
		return m.TradeNO
	}
	return ""
}

func (m *CompleteTradeArgs) GetRelatedID() string {
	if m != nil {
		return m.RelatedID
	}
	return ""
}

type CompleteTradeReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompleteTradeReply) Reset()         { *m = CompleteTradeReply{} }
func (m *CompleteTradeReply) String() string { return proto.CompactTextString(m) }
func (*CompleteTradeReply) ProtoMessage()    {}
func (*CompleteTradeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{13}
}
func (m *CompleteTradeReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteTradeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteTradeReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteTradeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteTradeReply.Merge(m, src)
}
func (m *CompleteTradeReply) XXX_Size() int {
	return m.Size()
}
func (m *CompleteTradeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteTradeReply.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteTradeReply proto.InternalMessageInfo

type FetchBalanceArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,2,opt,name=Currency,proto3" json:"Currency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchBalanceArgs) Reset()         { *m = FetchBalanceArgs{} }
func (m *FetchBalanceArgs) String() string { return proto.CompactTextString(m) }
func (*FetchBalanceArgs) ProtoMessage()    {}
func (*FetchBalanceArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{14}
}
func (m *FetchBalanceArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBalanceArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBalanceArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBalanceArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBalanceArgs.Merge(m, src)
}
func (m *FetchBalanceArgs) XXX_Size() int {
	return m.Size()
}
func (m *FetchBalanceArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBalanceArgs.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBalanceArgs proto.InternalMessageInfo

func (m *FetchBalanceArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *FetchBalanceArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type FetchBalanceReply struct {
	Balance              map[int32]*BalanceInfo `protobuf:"bytes,1,rep,name=Balance,proto3" json:"Balance,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FetchBalanceReply) Reset()         { *m = FetchBalanceReply{} }
func (m *FetchBalanceReply) String() string { return proto.CompactTextString(m) }
func (*FetchBalanceReply) ProtoMessage()    {}
func (*FetchBalanceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{15}
}
func (m *FetchBalanceReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBalanceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBalanceReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBalanceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBalanceReply.Merge(m, src)
}
func (m *FetchBalanceReply) XXX_Size() int {
	return m.Size()
}
func (m *FetchBalanceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBalanceReply.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBalanceReply proto.InternalMessageInfo

func (m *FetchBalanceReply) GetBalance() map[int32]*BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

type FetchBalancesArgs struct {
	UID                  int64    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchBalancesArgs) Reset()         { *m = FetchBalancesArgs{} }
func (m *FetchBalancesArgs) String() string { return proto.CompactTextString(m) }
func (*FetchBalancesArgs) ProtoMessage()    {}
func (*FetchBalancesArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{16}
}
func (m *FetchBalancesArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBalancesArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBalancesArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBalancesArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBalancesArgs.Merge(m, src)
}
func (m *FetchBalancesArgs) XXX_Size() int {
	return m.Size()
}
func (m *FetchBalancesArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBalancesArgs.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBalancesArgs proto.InternalMessageInfo

func (m *FetchBalancesArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

type FetchBalanceMap struct {
	Balance              map[int32]*BalanceInfo `protobuf:"bytes,1,rep,name=Balance,proto3" json:"Balance,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *FetchBalanceMap) Reset()         { *m = FetchBalanceMap{} }
func (m *FetchBalanceMap) String() string { return proto.CompactTextString(m) }
func (*FetchBalanceMap) ProtoMessage()    {}
func (*FetchBalanceMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{17}
}
func (m *FetchBalanceMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBalanceMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBalanceMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBalanceMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBalanceMap.Merge(m, src)
}
func (m *FetchBalanceMap) XXX_Size() int {
	return m.Size()
}
func (m *FetchBalanceMap) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBalanceMap.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBalanceMap proto.InternalMessageInfo

func (m *FetchBalanceMap) GetBalance() map[int32]*BalanceInfo {
	if m != nil {
		return m.Balance
	}
	return nil
}

type FetchBalancesReply struct {
	List                 map[string]*FetchBalanceMap `protobuf:"bytes,1,rep,name=List,proto3" json:"List,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *FetchBalancesReply) Reset()         { *m = FetchBalancesReply{} }
func (m *FetchBalancesReply) String() string { return proto.CompactTextString(m) }
func (*FetchBalancesReply) ProtoMessage()    {}
func (*FetchBalancesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{18}
}
func (m *FetchBalancesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchBalancesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchBalancesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchBalancesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchBalancesReply.Merge(m, src)
}
func (m *FetchBalancesReply) XXX_Size() int {
	return m.Size()
}
func (m *FetchBalancesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchBalancesReply.DiscardUnknown(m)
}

var xxx_messageInfo_FetchBalancesReply proto.InternalMessageInfo

func (m *FetchBalancesReply) GetList() map[string]*FetchBalanceMap {
	if m != nil {
		return m.List
	}
	return nil
}

type BalanceInfo struct {
	Currency             string   `protobuf:"bytes,1,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Cash                 float64  `protobuf:"fixed64,2,opt,name=Cash,proto3" json:"Cash,omitempty"`
	Used                 float64  `protobuf:"fixed64,3,opt,name=Used,proto3" json:"Used,omitempty"`
	IsDefault            bool     `protobuf:"varint,4,opt,name=IsDefault,proto3" json:"IsDefault,omitempty"`
	AmountKind           int32    `protobuf:"varint,5,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BalanceInfo) Reset()         { *m = BalanceInfo{} }
func (m *BalanceInfo) String() string { return proto.CompactTextString(m) }
func (*BalanceInfo) ProtoMessage()    {}
func (*BalanceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{19}
}
func (m *BalanceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BalanceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BalanceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BalanceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BalanceInfo.Merge(m, src)
}
func (m *BalanceInfo) XXX_Size() int {
	return m.Size()
}
func (m *BalanceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BalanceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BalanceInfo proto.InternalMessageInfo

func (m *BalanceInfo) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *BalanceInfo) GetCash() float64 {
	if m != nil {
		return m.Cash
	}
	return 0
}

func (m *BalanceInfo) GetUsed() float64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *BalanceInfo) GetIsDefault() bool {
	if m != nil {
		return m.IsDefault
	}
	return false
}

func (m *BalanceInfo) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

type ChangeInfo struct {
	Currency             string   `protobuf:"bytes,1,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Cash                 float64  `protobuf:"fixed64,3,opt,name=Cash,proto3" json:"Cash,omitempty"`
	AmountKind           int32    `protobuf:"varint,4,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChangeInfo) Reset()         { *m = ChangeInfo{} }
func (m *ChangeInfo) String() string { return proto.CompactTextString(m) }
func (*ChangeInfo) ProtoMessage()    {}
func (*ChangeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{20}
}
func (m *ChangeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeInfo.Merge(m, src)
}
func (m *ChangeInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChangeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeInfo proto.InternalMessageInfo

func (m *ChangeInfo) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *ChangeInfo) GetCash() float64 {
	if m != nil {
		return m.Cash
	}
	return 0
}

func (m *ChangeInfo) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

type FetchTradeListArgs struct {
	Page                 int32    `protobuf:"varint,1,opt,name=Page,proto3" json:"Page,omitempty"`
	Limit                int32    `protobuf:"varint,2,opt,name=Limit,proto3" json:"Limit,omitempty"`
	UID                  int64    `protobuf:"varint,3,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,5,opt,name=Currency,proto3" json:"Currency,omitempty"`
	Types                []int32  `protobuf:"varint,6,rep,packed,name=Types,proto3" json:"Types,omitempty"`
	StartTime            string   `protobuf:"bytes,7,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	EndTime              string   `protobuf:"bytes,8,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	HasMore              bool     `protobuf:"varint,9,opt,name=HasMore,proto3" json:"HasMore,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchTradeListArgs) Reset()         { *m = FetchTradeListArgs{} }
func (m *FetchTradeListArgs) String() string { return proto.CompactTextString(m) }
func (*FetchTradeListArgs) ProtoMessage()    {}
func (*FetchTradeListArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{21}
}
func (m *FetchTradeListArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchTradeListArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchTradeListArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchTradeListArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchTradeListArgs.Merge(m, src)
}
func (m *FetchTradeListArgs) XXX_Size() int {
	return m.Size()
}
func (m *FetchTradeListArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchTradeListArgs.DiscardUnknown(m)
}

var xxx_messageInfo_FetchTradeListArgs proto.InternalMessageInfo

func (m *FetchTradeListArgs) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FetchTradeListArgs) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FetchTradeListArgs) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *FetchTradeListArgs) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *FetchTradeListArgs) GetTypes() []int32 {
	if m != nil {
		return m.Types
	}
	return nil
}

func (m *FetchTradeListArgs) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *FetchTradeListArgs) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *FetchTradeListArgs) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

type FetchTradeListReply struct {
	Total                int32        `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty"`
	Page                 int32        `protobuf:"varint,2,opt,name=Page,proto3" json:"Page,omitempty"`
	Limit                int32        `protobuf:"varint,3,opt,name=Limit,proto3" json:"Limit,omitempty"`
	HasMore              bool         `protobuf:"varint,4,opt,name=HasMore,proto3" json:"HasMore,omitempty"`
	List                 []*TradeInfo `protobuf:"bytes,5,rep,name=List,proto3" json:"List,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *FetchTradeListReply) Reset()         { *m = FetchTradeListReply{} }
func (m *FetchTradeListReply) String() string { return proto.CompactTextString(m) }
func (*FetchTradeListReply) ProtoMessage()    {}
func (*FetchTradeListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{22}
}
func (m *FetchTradeListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchTradeListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchTradeListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchTradeListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchTradeListReply.Merge(m, src)
}
func (m *FetchTradeListReply) XXX_Size() int {
	return m.Size()
}
func (m *FetchTradeListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchTradeListReply.DiscardUnknown(m)
}

var xxx_messageInfo_FetchTradeListReply proto.InternalMessageInfo

func (m *FetchTradeListReply) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *FetchTradeListReply) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *FetchTradeListReply) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *FetchTradeListReply) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

func (m *FetchTradeListReply) GetList() []*TradeInfo {
	if m != nil {
		return m.List
	}
	return nil
}

type TradeInfo struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NO                   string   `protobuf:"bytes,2,opt,name=NO,proto3" json:"NO,omitempty"`
	UID                  int64    `protobuf:"varint,3,opt,name=UID,proto3" json:"UID,omitempty"`
	Currency             string   `protobuf:"bytes,4,opt,name=Currency,proto3" json:"Currency,omitempty"`
	BeforeCash           float64  `protobuf:"fixed64,6,opt,name=BeforeCash,proto3" json:"BeforeCash,omitempty"`
	AfterCash            float64  `protobuf:"fixed64,7,opt,name=AfterCash,proto3" json:"AfterCash,omitempty"`
	ChangeCash           float64  `protobuf:"fixed64,9,opt,name=ChangeCash,proto3" json:"ChangeCash,omitempty"`
	Type                 int32    `protobuf:"varint,11,opt,name=Type,proto3" json:"Type,omitempty"`
	Status               int32    `protobuf:"varint,12,opt,name=Status,proto3" json:"Status,omitempty"`
	CreatedAt            int64    `protobuf:"varint,13,opt,name=CreatedAt,proto3" json:"CreatedAt,omitempty"`
	UpdatedAt            int64    `protobuf:"varint,14,opt,name=UpdatedAt,proto3" json:"UpdatedAt,omitempty"`
	BetCash              float64  `protobuf:"fixed64,15,opt,name=BetCash,proto3" json:"BetCash,omitempty"`
	UserCode             string   `protobuf:"bytes,16,opt,name=UserCode,proto3" json:"UserCode,omitempty"`
	NickName             string   `protobuf:"bytes,17,opt,name=NickName,proto3" json:"NickName,omitempty"`
	ChannelCode          string   `protobuf:"bytes,19,opt,name=ChannelCode,proto3" json:"ChannelCode,omitempty"`
	Channel              string   `protobuf:"bytes,20,opt,name=Channel,proto3" json:"Channel,omitempty"`
	AmountKind           int32    `protobuf:"varint,21,opt,name=AmountKind,proto3" json:"AmountKind,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradeInfo) Reset()         { *m = TradeInfo{} }
func (m *TradeInfo) String() string { return proto.CompactTextString(m) }
func (*TradeInfo) ProtoMessage()    {}
func (*TradeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b88fd140af4deb6f, []int{23}
}
func (m *TradeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeInfo.Merge(m, src)
}
func (m *TradeInfo) XXX_Size() int {
	return m.Size()
}
func (m *TradeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TradeInfo proto.InternalMessageInfo

func (m *TradeInfo) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TradeInfo) GetNO() string {
	if m != nil {
		return m.NO
	}
	return ""
}

func (m *TradeInfo) GetUID() int64 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *TradeInfo) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *TradeInfo) GetBeforeCash() float64 {
	if m != nil {
		return m.BeforeCash
	}
	return 0
}

func (m *TradeInfo) GetAfterCash() float64 {
	if m != nil {
		return m.AfterCash
	}
	return 0
}

func (m *TradeInfo) GetChangeCash() float64 {
	if m != nil {
		return m.ChangeCash
	}
	return 0
}

func (m *TradeInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *TradeInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *TradeInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *TradeInfo) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *TradeInfo) GetBetCash() float64 {
	if m != nil {
		return m.BetCash
	}
	return 0
}

func (m *TradeInfo) GetUserCode() string {
	if m != nil {
		return m.UserCode
	}
	return ""
}

func (m *TradeInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *TradeInfo) GetChannelCode() string {
	if m != nil {
		return m.ChannelCode
	}
	return ""
}

func (m *TradeInfo) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *TradeInfo) GetAmountKind() int32 {
	if m != nil {
		return m.AmountKind
	}
	return 0
}

func init() {
	proto.RegisterType((*InitWalletArgs)(nil), "pb.InitWalletArgs")
	proto.RegisterType((*InitWalletReply)(nil), "pb.InitWalletReply")
	proto.RegisterType((*SetDefaultCurrencyArgs)(nil), "pb.SetDefaultCurrencyArgs")
	proto.RegisterType((*SetDefaultCurrencyReply)(nil), "pb.SetDefaultCurrencyReply")
	proto.RegisterType((*IncrBalanceArgs)(nil), "pb.IncrBalanceArgs")
	proto.RegisterType((*IncrBalanceReply)(nil), "pb.IncrBalanceReply")
	proto.RegisterType((*DecrBalanceArgs)(nil), "pb.DecrBalanceArgs")
	proto.RegisterType((*DecrBalanceReply)(nil), "pb.DecrBalanceReply")
	proto.RegisterType((*FreezeBalanceArgs)(nil), "pb.FreezeBalanceArgs")
	proto.RegisterType((*FreezeBalanceReply)(nil), "pb.FreezeBalanceReply")
	proto.RegisterType((*CancelTradeArgs)(nil), "pb.CancelTradeArgs")
	proto.RegisterType((*CancelTradeReply)(nil), "pb.CancelTradeReply")
	proto.RegisterType((*CompleteTradeArgs)(nil), "pb.CompleteTradeArgs")
	proto.RegisterType((*CompleteTradeReply)(nil), "pb.CompleteTradeReply")
	proto.RegisterType((*FetchBalanceArgs)(nil), "pb.FetchBalanceArgs")
	proto.RegisterType((*FetchBalanceReply)(nil), "pb.FetchBalanceReply")
	proto.RegisterMapType((map[int32]*BalanceInfo)(nil), "pb.FetchBalanceReply.BalanceEntry")
	proto.RegisterType((*FetchBalancesArgs)(nil), "pb.FetchBalancesArgs")
	proto.RegisterType((*FetchBalanceMap)(nil), "pb.FetchBalanceMap")
	proto.RegisterMapType((map[int32]*BalanceInfo)(nil), "pb.FetchBalanceMap.BalanceEntry")
	proto.RegisterType((*FetchBalancesReply)(nil), "pb.FetchBalancesReply")
	proto.RegisterMapType((map[string]*FetchBalanceMap)(nil), "pb.FetchBalancesReply.ListEntry")
	proto.RegisterType((*BalanceInfo)(nil), "pb.BalanceInfo")
	proto.RegisterType((*ChangeInfo)(nil), "pb.ChangeInfo")
	proto.RegisterType((*FetchTradeListArgs)(nil), "pb.FetchTradeListArgs")
	proto.RegisterType((*FetchTradeListReply)(nil), "pb.FetchTradeListReply")
	proto.RegisterType((*TradeInfo)(nil), "pb.TradeInfo")
}

func init() { proto.RegisterFile("wallet.proto", fileDescriptor_b88fd140af4deb6f) }

var fileDescriptor_b88fd140af4deb6f = []byte{
	// 1243 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x5f, 0x6b, 0x2b, 0x45,
	0x14, 0xef, 0x26, 0xd9, 0x34, 0x39, 0x69, 0x93, 0x76, 0x9a, 0x9b, 0xbb, 0x46, 0x09, 0x71, 0xf1,
	0x5e, 0x72, 0x5f, 0x2a, 0x54, 0x41, 0xb9, 0x28, 0xdc, 0x36, 0xb9, 0xd5, 0xd0, 0x7f, 0x97, 0x6d,
	0x8b, 0x20, 0xbe, 0x4c, 0x93, 0x69, 0x1b, 0xee, 0x66, 0x37, 0xec, 0x4e, 0xd5, 0xf8, 0x22, 0x7e,
	0x02, 0xc5, 0xa7, 0x8b, 0x0f, 0x7e, 0x1e, 0x41, 0x04, 0x1f, 0x04, 0x5f, 0xa5, 0x7e, 0x11, 0x99,
	0x33, 0xb3, 0x9b, 0xd9, 0x49, 0xa2, 0xd7, 0x3f, 0x78, 0x41, 0x7c, 0xcb, 0xf9, 0x9d, 0x99, 0xf3,
	0x6f, 0x7e, 0x7b, 0xe6, 0x4c, 0x60, 0xed, 0x13, 0xea, 0xfb, 0x8c, 0x6f, 0x4f, 0xa2, 0x90, 0x87,
	0x24, 0x37, 0xb9, 0x70, 0xaf, 0xa1, 0xda, 0x0f, 0x46, 0xfc, 0x03, 0xc4, 0x77, 0xa3, 0xab, 0x98,
	0x6c, 0x40, 0xfe, 0xbc, 0xdf, 0x73, 0xac, 0xb6, 0xd5, 0xc9, 0x7b, 0xe2, 0x27, 0xe9, 0x40, 0xad,
	0xc7, 0x2e, 0xe9, 0x8d, 0xcf, 0xbb, 0x37, 0x51, 0xc4, 0x82, 0xc1, 0xd4, 0xc9, 0xb5, 0xad, 0x4e,
	0xd9, 0x33, 0x61, 0xd2, 0x84, 0x92, 0xb0, 0xd6, 0xa5, 0xf1, 0xb5, 0x93, 0x6f, 0x5b, 0x1d, 0xcb,
	0x4b, 0x65, 0x77, 0x13, 0x6a, 0x33, 0x4f, 0x1e, 0x9b, 0xf8, 0x53, 0x77, 0x1f, 0x1a, 0xa7, 0x8c,
	0x1b, 0x46, 0x96, 0x04, 0xd1, 0x84, 0x92, 0xe1, 0x3d, 0x95, 0xdd, 0x97, 0xe0, 0xee, 0xbc, 0x1d,
	0xe9, 0xe2, 0xfb, 0xbc, 0x70, 0x3b, 0x88, 0xf6, 0xa8, 0x4f, 0x83, 0x01, 0xfb, 0xf3, 0xc6, 0x09,
	0x81, 0x82, 0x96, 0x0f, 0xfe, 0x16, 0xd8, 0xd9, 0x74, 0xc2, 0x9c, 0x42, 0xdb, 0xea, 0xd8, 0x1e,
	0xfe, 0x26, 0xaf, 0x40, 0xd9, 0x63, 0x3e, 0xe5, 0x6c, 0xd8, 0xef, 0x39, 0xab, 0x68, 0x64, 0x06,
	0x08, 0x0f, 0x67, 0xf4, 0x53, 0xca, 0x47, 0x61, 0xe0, 0x94, 0x64, 0x65, 0x12, 0x59, 0xec, 0xdc,
	0x63, 0x7c, 0x77, 0x1c, 0xde, 0x04, 0xdc, 0x29, 0xa3, 0x72, 0x06, 0x90, 0x06, 0x14, 0x3d, 0x76,
	0x41, 0x39, 0x73, 0xa0, 0x6d, 0x75, 0x4a, 0x9e, 0x92, 0x84, 0xc5, 0xf7, 0xe8, 0x98, 0x1d, 0xd3,
	0x31, 0x73, 0x2a, 0x32, 0xe6, 0x44, 0x26, 0x2d, 0x00, 0xb9, 0xfb, 0x60, 0x14, 0x0c, 0x9d, 0x35,
	0x8c, 0x52, 0x43, 0xc8, 0x7d, 0xa8, 0x3e, 0xf1, 0xe9, 0x34, 0xc9, 0xb1, 0xdf, 0x73, 0xd6, 0xb1,
	0x18, 0x06, 0x4a, 0x5c, 0x58, 0xd3, 0x11, 0xa7, 0x8a, 0x7e, 0x32, 0x98, 0x88, 0x03, 0x65, 0x51,
	0xa3, 0x9a, 0xcc, 0x2c, 0x91, 0xc9, 0x6b, 0xb0, 0x7e, 0x16, 0xd1, 0x20, 0xa6, 0x03, 0x91, 0x68,
	0xbf, 0xe7, 0x6c, 0xa0, 0x81, 0x2c, 0x28, 0xf8, 0x75, 0x1e, 0xb3, 0xa8, 0x1b, 0x06, 0x3c, 0x0a,
	0x7d, 0x0c, 0x79, 0x13, 0x43, 0x36, 0x61, 0xf7, 0x73, 0xd8, 0xd0, 0x0e, 0x13, 0x4f, 0x98, 0x38,
	0xb0, 0x7a, 0x16, 0xd1, 0x21, 0x3b, 0x3e, 0xc1, 0x13, 0x2d, 0x7b, 0x89, 0x48, 0x1e, 0xc0, 0xaa,
	0x5a, 0x89, 0x87, 0x5a, 0xd9, 0xa9, 0x6d, 0x4f, 0x2e, 0xb6, 0x15, 0xd4, 0x0f, 0x2e, 0x43, 0x2f,
	0xd1, 0x93, 0xfb, 0x50, 0xec, 0x5e, 0xd3, 0xe0, 0x8a, 0xe1, 0x31, 0x57, 0x76, 0xaa, 0x62, 0xa5,
	0x44, 0x70, 0xa1, 0xd2, 0x22, 0x9d, 0x7a, 0xec, 0x7f, 0x3a, 0xfd, 0x67, 0xe8, 0xa4, 0x1d, 0xe6,
	0x0b, 0xa0, 0xd3, 0xcf, 0x16, 0x6c, 0xee, 0x47, 0x8c, 0x7d, 0xc6, 0xfe, 0x59, 0x42, 0x35, 0xa0,
	0xa8, 0xce, 0xdf, 0x46, 0x54, 0x49, 0x29, 0xd1, 0x8a, 0xcb, 0x88, 0x56, 0x36, 0x89, 0xb6, 0x8c,
	0x2e, 0x59, 0x4a, 0x54, 0x4c, 0x4a, 0xb8, 0x5f, 0x58, 0x40, 0x32, 0x99, 0xbd, 0x80, 0xea, 0xf6,
	0xa1, 0xd6, 0x15, 0x1b, 0x7c, 0xf4, 0x81, 0xa5, 0x5d, 0xee, 0x3f, 0x53, 0x86, 0x82, 0x51, 0x06,
	0x97, 0xc1, 0x86, 0x66, 0x4a, 0xe6, 0xa2, 0x45, 0x6c, 0x3d, 0x77, 0xc4, 0xb9, 0xdf, 0x8d, 0xf8,
	0x00, 0x36, 0xbb, 0xe1, 0x78, 0xe2, 0x33, 0xce, 0xfe, 0x7e, 0xcc, 0x75, 0x20, 0x19, 0x63, 0xf2,
	0x42, 0x7c, 0x04, 0x1b, 0xfb, 0x8c, 0x0f, 0xae, 0xff, 0x32, 0xe1, 0xdc, 0x6f, 0x05, 0x69, 0x35,
	0x13, 0xb2, 0x1a, 0xef, 0xe8, 0xd5, 0xc8, 0x77, 0x2a, 0x3b, 0xae, 0xc8, 0x71, 0x6e, 0x5d, 0x52,
	0x9f, 0xc7, 0x01, 0x8f, 0xa6, 0x69, 0x81, 0x9a, 0x07, 0xb0, 0xa6, 0x2b, 0x44, 0x44, 0x4f, 0xd9,
	0x14, 0x23, 0xb2, 0x3d, 0xf1, 0x93, 0xdc, 0x03, 0xfb, 0x63, 0xea, 0xdf, 0x2c, 0x65, 0x87, 0xd4,
	0x3e, 0xcc, 0xbd, 0x6d, 0xb9, 0xf7, 0xb2, 0xf1, 0xc5, 0x8b, 0x73, 0x74, 0xbf, 0xb1, 0xa0, 0xa6,
	0xaf, 0x3b, 0xa2, 0x13, 0xf2, 0xd0, 0xcc, 0xa2, 0x6d, 0x66, 0x71, 0x44, 0x27, 0xff, 0x46, 0x0e,
	0xcf, 0xc4, 0xf7, 0xa3, 0x27, 0x21, 0xab, 0xfc, 0x26, 0x14, 0x0e, 0x47, 0x31, 0x5f, 0x16, 0x9c,
	0x5c, 0xb5, 0x2d, 0x96, 0xc8, 0xe0, 0x70, 0x75, 0xf3, 0x10, 0xca, 0x29, 0xa4, 0x87, 0x55, 0x96,
	0x61, 0x3d, 0xc8, 0x86, 0xb5, 0xb5, 0x20, 0x65, 0x3d, 0xb4, 0x2f, 0x2d, 0xa8, 0x68, 0x51, 0x67,
	0xb8, 0x62, 0x2d, 0x69, 0x4e, 0xb9, 0xec, 0x6d, 0x77, 0x1e, 0xb3, 0x61, 0xd2, 0xb0, 0xc4, 0x6f,
	0xc1, 0xe4, 0x7e, 0xac, 0x06, 0x38, 0x64, 0x72, 0xc9, 0x9b, 0x01, 0x46, 0xb3, 0xb1, 0xe7, 0x9a,
	0xcd, 0x47, 0x00, 0xb3, 0x8f, 0xe9, 0xb9, 0xe2, 0xd1, 0x9b, 0x65, 0xd6, 0x7a, 0x61, 0xce, 0xfa,
	0x4f, 0xc9, 0x51, 0xe0, 0x57, 0x24, 0x0a, 0x89, 0x84, 0x22, 0x50, 0x78, 0x42, 0xaf, 0x98, 0x3a,
	0x5f, 0xfc, 0x4d, 0xea, 0x60, 0x1f, 0x8e, 0xc6, 0x23, 0x8e, 0xf9, 0xda, 0x9e, 0x14, 0x12, 0xea,
	0xe5, 0x17, 0x7f, 0x5e, 0xb6, 0x11, 0x62, 0x1d, 0x6c, 0xd1, 0x97, 0x63, 0xa7, 0xd8, 0xce, 0x0b,
	0x1b, 0x28, 0x88, 0x02, 0x9d, 0x72, 0x1a, 0xf1, 0xb3, 0xd1, 0x98, 0x25, 0xe3, 0x40, 0x0a, 0x88,
	0x16, 0xf1, 0x38, 0x18, 0xa2, 0xae, 0x24, 0x5b, 0x84, 0x12, 0x85, 0xe6, 0x7d, 0x1a, 0x1f, 0x85,
	0x11, 0xc3, 0xde, 0x5e, 0xf2, 0x12, 0xd1, 0xfd, 0xda, 0x82, 0xad, 0x6c, 0x5a, 0x92, 0x62, 0xc2,
	0x7f, 0xc8, 0xa9, 0xaf, 0x12, 0x93, 0x42, 0x9a, 0x6d, 0x6e, 0x51, 0xb6, 0x79, 0x3d, 0x5b, 0xcd,
	0x63, 0x21, 0xe3, 0x91, 0xbc, 0xaa, 0xc8, 0x6b, 0x23, 0x79, 0xd7, 0x05, 0xcd, 0xd0, 0x37, 0x72,
	0x1f, 0x55, 0xee, 0x0f, 0x79, 0x28, 0xa7, 0x18, 0xa9, 0x42, 0x2e, 0xfd, 0x64, 0x73, 0xfd, 0x9e,
	0x90, 0x8f, 0x4f, 0x54, 0x3f, 0xca, 0x1d, 0x9f, 0xfc, 0x41, 0x61, 0x0b, 0x46, 0x61, 0x5b, 0x00,
	0x7b, 0xec, 0x32, 0x8c, 0x18, 0x32, 0xa0, 0x88, 0x0c, 0xd0, 0x10, 0x51, 0xe2, 0xdd, 0x4b, 0xce,
	0x22, 0x54, 0xaf, 0xca, 0xb9, 0x29, 0x05, 0xc4, 0x6e, 0xc9, 0x31, 0x54, 0xcb, 0xb1, 0x4a, 0x43,
	0xd2, 0xab, 0xb5, 0xa2, 0x5d, 0xad, 0x0d, 0x28, 0x9e, 0x72, 0xca, 0x6f, 0x62, 0x35, 0x33, 0x29,
	0x49, 0x78, 0xea, 0x46, 0x4c, 0xb4, 0xe9, 0x5d, 0xae, 0x46, 0xa5, 0x19, 0x20, 0xb4, 0xe7, 0x93,
	0xa1, 0xd2, 0x56, 0xa5, 0x36, 0x05, 0x44, 0x79, 0xf7, 0x18, 0xd7, 0xc6, 0xa3, 0x44, 0x14, 0xb9,
	0xcb, 0x01, 0x67, 0xc8, 0xd4, 0x60, 0x94, 0xca, 0x42, 0x77, 0x3c, 0x1a, 0x3c, 0xc5, 0xe9, 0x6e,
	0x53, 0xea, 0x12, 0x99, 0xb4, 0xa1, 0x22, 0xf2, 0x08, 0x98, 0x8f, 0x5b, 0xb7, 0x50, 0xad, 0x43,
	0xc2, 0xa7, 0x12, 0x9d, 0xba, 0xa4, 0x97, 0x12, 0x8d, 0x6f, 0xe7, 0x8e, 0xf9, 0xed, 0xec, 0x7c,
	0x65, 0x43, 0x51, 0xbe, 0xf8, 0xc8, 0x5b, 0x00, 0xb3, 0xf7, 0x1f, 0x21, 0xe2, 0xf4, 0xb3, 0x2f,
	0xcf, 0xe6, 0x56, 0x16, 0x93, 0xf7, 0xd5, 0x0a, 0x39, 0x01, 0x32, 0xff, 0xba, 0x23, 0x4d, 0xb1,
	0x78, 0xf1, 0xeb, 0xb1, 0xf9, 0xf2, 0x62, 0x5d, 0x62, 0xf0, 0x21, 0x54, 0xb4, 0x57, 0x04, 0x51,
	0x6e, 0x33, 0x43, 0x7d, 0xb3, 0x6e, 0x80, 0xda, 0x5e, 0x6d, 0x64, 0x94, 0x7b, 0x8d, 0x07, 0x81,
	0xdc, 0x6b, 0x0e, 0x96, 0xee, 0x0a, 0x79, 0x04, 0xeb, 0x99, 0x91, 0x88, 0xdc, 0xc1, 0x4e, 0x6b,
	0xce, 0x7f, 0xcd, 0xc6, 0x1c, 0xac, 0x79, 0xd7, 0xc6, 0x10, 0xe9, 0xdd, 0x18, 0x71, 0xa4, 0x77,
	0x73, 0x58, 0x91, 0xde, 0x33, 0xe3, 0x80, 0xf4, 0x3e, 0x37, 0x6e, 0x48, 0xef, 0x0b, 0x06, 0x87,
	0x15, 0xf2, 0x2e, 0xac, 0xe9, 0xd7, 0x02, 0xa9, 0x9b, 0x17, 0x05, 0xee, 0xbf, 0xb3, 0xf0, 0xde,
	0x57, 0xe9, 0xeb, 0x77, 0x15, 0x99, 0x5b, 0x19, 0x6b, 0xe9, 0xcf, 0xdd, 0x6a, 0xee, 0x0a, 0xe9,
	0x42, 0x35, 0xdb, 0xb1, 0xc8, 0x6c, 0x6d, 0xa6, 0x39, 0x37, 0xef, 0xce, 0xe3, 0xca, 0xc8, 0x5e,
	0xe3, 0xbb, 0xdb, 0x96, 0xf5, 0xe3, 0x6d, 0xcb, 0xfa, 0xe5, 0xb6, 0x65, 0x3d, 0xfb, 0xb5, 0xb5,
	0xf2, 0x61, 0x61, 0xfb, 0xf5, 0xc9, 0xc5, 0x45, 0x11, 0xff, 0x14, 0x79, 0xe3, 0xb7, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x80, 0x4c, 0xff, 0xc5, 0x24, 0x11, 0x00, 0x00,
}

func (m *InitWalletArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitWalletArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitWalletArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InitCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.InitCash))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.DefaultCurrency) > 0 {
		i -= len(m.DefaultCurrency)
		copy(dAtA[i:], m.DefaultCurrency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.DefaultCurrency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InitWalletReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitWalletReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitWalletReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SetDefaultCurrencyArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDefaultCurrencyArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDefaultCurrencyArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetDefaultCurrencyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDefaultCurrencyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetDefaultCurrencyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *IncrBalanceArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrBalanceArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrBalanceArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserControlKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UserControlKind))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PlayCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PlayCash))))
		i--
		dAtA[i] = 0x79
	}
	if len(m.PlayCurrency) > 0 {
		i -= len(m.PlayCurrency)
		copy(dAtA[i:], m.PlayCurrency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.PlayCurrency)))
		i--
		dAtA[i] = 0x72
	}
	if m.PlayCurrencyID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.PlayCurrencyID))
		i--
		dAtA[i] = 0x68
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x60
	}
	if len(m.GameName) > 0 {
		i -= len(m.GameName)
		copy(dAtA[i:], m.GameName)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GameName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Rebate {
		i--
		if m.Rebate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.BetAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BetAmount))))
		i--
		dAtA[i] = 0x49
	}
	if m.Taxation != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Taxation))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.RelatedID) > 0 {
		i -= len(m.RelatedID)
		copy(dAtA[i:], m.RelatedID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.RelatedID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Type != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Cash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cash))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IncrBalanceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncrBalanceReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IncrBalanceReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeNO) > 0 {
		i -= len(m.TradeNO)
		copy(dAtA[i:], m.TradeNO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TradeNO)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecrBalanceArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecrBalanceArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecrBalanceArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserControlKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UserControlKind))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.TransactionID) > 0 {
		i -= len(m.TransactionID)
		copy(dAtA[i:], m.TransactionID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TransactionID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.PlayCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.PlayCash))))
		i--
		dAtA[i] = 0x79
	}
	if len(m.PlayCurrency) > 0 {
		i -= len(m.PlayCurrency)
		copy(dAtA[i:], m.PlayCurrency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.PlayCurrency)))
		i--
		dAtA[i] = 0x72
	}
	if m.PlayCurrencyID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.PlayCurrencyID))
		i--
		dAtA[i] = 0x68
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x60
	}
	if len(m.GameName) > 0 {
		i -= len(m.GameName)
		copy(dAtA[i:], m.GameName)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.GameName)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Rebate {
		i--
		if m.Rebate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.BetAmount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BetAmount))))
		i--
		dAtA[i] = 0x49
	}
	if m.Taxation != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Taxation))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.RelatedID) > 0 {
		i -= len(m.RelatedID)
		copy(dAtA[i:], m.RelatedID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.RelatedID)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Type != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Cash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cash))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DecrBalanceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecrBalanceReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecrBalanceReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeNO) > 0 {
		i -= len(m.TradeNO)
		copy(dAtA[i:], m.TradeNO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TradeNO)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FreezeBalanceArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreezeBalanceArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FreezeBalanceArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x58
	}
	if m.Rebate {
		i--
		if m.Rebate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.RelatedID) > 0 {
		i -= len(m.RelatedID)
		copy(dAtA[i:], m.RelatedID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.RelatedID)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Type != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if m.Amount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Amount))))
		i--
		dAtA[i] = 0x29
	}
	if m.Cash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cash))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FreezeBalanceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FreezeBalanceReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FreezeBalanceReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.TradeNO) > 0 {
		i -= len(m.TradeNO)
		copy(dAtA[i:], m.TradeNO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TradeNO)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelTradeArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTradeArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelTradeArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelatedID) > 0 {
		i -= len(m.RelatedID)
		copy(dAtA[i:], m.RelatedID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.RelatedID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TradeNO) > 0 {
		i -= len(m.TradeNO)
		copy(dAtA[i:], m.TradeNO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TradeNO)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelTradeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTradeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelTradeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Change != nil {
		{
			size, err := m.Change.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintWallet(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteTradeArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteTradeArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteTradeArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RelatedID) > 0 {
		i -= len(m.RelatedID)
		copy(dAtA[i:], m.RelatedID)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.RelatedID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TradeNO) > 0 {
		i -= len(m.TradeNO)
		copy(dAtA[i:], m.TradeNO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.TradeNO)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompleteTradeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteTradeReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteTradeReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *FetchBalanceArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBalanceArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBalanceArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchBalanceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBalanceReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBalanceReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Balance) > 0 {
		for k := range m.Balance {
			v := m.Balance[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintWallet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintWallet(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintWallet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchBalancesArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBalancesArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBalancesArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchBalanceMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBalanceMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBalanceMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Balance) > 0 {
		for k := range m.Balance {
			v := m.Balance[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintWallet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintWallet(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintWallet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FetchBalancesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchBalancesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchBalancesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for k := range m.List {
			v := m.List[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintWallet(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintWallet(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintWallet(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BalanceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BalanceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BalanceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x28
	}
	if m.IsDefault {
		i--
		if m.IsDefault {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Used != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Used))))
		i--
		dAtA[i] = 0x19
	}
	if m.Cash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cash))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x20
	}
	if m.Cash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Cash))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchTradeListArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchTradeListArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchTradeListArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.EndTime) > 0 {
		i -= len(m.EndTime)
		copy(dAtA[i:], m.EndTime)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.EndTime)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.StartTime) > 0 {
		i -= len(m.StartTime)
		copy(dAtA[i:], m.StartTime)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.StartTime)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Types) > 0 {
		dAtA13 := make([]byte, len(m.Types)*10)
		var j12 int
		for _, num1 := range m.Types {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		i -= j12
		copy(dAtA[i:], dAtA13[:j12])
		i = encodeVarintWallet(dAtA, i, uint64(j12))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FetchTradeListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchTradeListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchTradeListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.List) > 0 {
		for iNdEx := len(m.List) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.List[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintWallet(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.HasMore {
		i--
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if m.Page != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x10
	}
	if m.Total != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TradeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AmountKind != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.AmountKind))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.Channel) > 0 {
		i -= len(m.Channel)
		copy(dAtA[i:], m.Channel)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Channel)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.ChannelCode) > 0 {
		i -= len(m.ChannelCode)
		copy(dAtA[i:], m.ChannelCode)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.ChannelCode)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.NickName) > 0 {
		i -= len(m.NickName)
		copy(dAtA[i:], m.NickName)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.NickName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.UserCode) > 0 {
		i -= len(m.UserCode)
		copy(dAtA[i:], m.UserCode)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.UserCode)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.BetCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BetCash))))
		i--
		dAtA[i] = 0x79
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x70
	}
	if m.CreatedAt != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x68
	}
	if m.Status != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x60
	}
	if m.Type != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x58
	}
	if m.ChangeCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ChangeCash))))
		i--
		dAtA[i] = 0x49
	}
	if m.AfterCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AfterCash))))
		i--
		dAtA[i] = 0x39
	}
	if m.BeforeCash != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.BeforeCash))))
		i--
		dAtA[i] = 0x31
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x22
	}
	if m.UID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NO) > 0 {
		i -= len(m.NO)
		copy(dAtA[i:], m.NO)
		i = encodeVarintWallet(dAtA, i, uint64(len(m.NO)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintWallet(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintWallet(dAtA []byte, offset int, v uint64) int {
	offset -= sovWallet(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InitWalletArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.DefaultCurrency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.InitCash != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitWalletReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetDefaultCurrencyArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetDefaultCurrencyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncrBalanceArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Cash != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovWallet(uint64(m.Type))
	}
	l = len(m.RelatedID)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Taxation != 0 {
		n += 9
	}
	if m.BetAmount != 0 {
		n += 9
	}
	if m.Rebate {
		n += 2
	}
	l = len(m.GameName)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.AmountKind != 0 {
		n += 1 + sovWallet(uint64(m.AmountKind))
	}
	if m.PlayCurrencyID != 0 {
		n += 1 + sovWallet(uint64(m.PlayCurrencyID))
	}
	l = len(m.PlayCurrency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.PlayCash != 0 {
		n += 9
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	if m.UserControlKind != 0 {
		n += 2 + sovWallet(uint64(m.UserControlKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IncrBalanceReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeNO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecrBalanceArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Cash != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovWallet(uint64(m.Type))
	}
	l = len(m.RelatedID)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Taxation != 0 {
		n += 9
	}
	if m.BetAmount != 0 {
		n += 9
	}
	if m.Rebate {
		n += 2
	}
	l = len(m.GameName)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.AmountKind != 0 {
		n += 1 + sovWallet(uint64(m.AmountKind))
	}
	if m.PlayCurrencyID != 0 {
		n += 1 + sovWallet(uint64(m.PlayCurrencyID))
	}
	l = len(m.PlayCurrency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.PlayCash != 0 {
		n += 9
	}
	l = len(m.TransactionID)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	if m.UserControlKind != 0 {
		n += 2 + sovWallet(uint64(m.UserControlKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecrBalanceReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeNO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FreezeBalanceArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Cash != 0 {
		n += 9
	}
	if m.Amount != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovWallet(uint64(m.Type))
	}
	l = len(m.RelatedID)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Rebate {
		n += 2
	}
	if m.AmountKind != 0 {
		n += 1 + sovWallet(uint64(m.AmountKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FreezeBalanceReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeNO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelTradeArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeNO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.RelatedID)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelTradeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Change != nil {
		l = m.Change.Size()
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteTradeArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TradeNO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.RelatedID)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompleteTradeReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchBalanceArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchBalanceReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balance) > 0 {
		for k, v := range m.Balance {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWallet(uint64(l))
			}
			mapEntrySize := 1 + sovWallet(uint64(k)) + l
			n += mapEntrySize + 1 + sovWallet(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchBalancesArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchBalanceMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Balance) > 0 {
		for k, v := range m.Balance {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWallet(uint64(l))
			}
			mapEntrySize := 1 + sovWallet(uint64(k)) + l
			n += mapEntrySize + 1 + sovWallet(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchBalancesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovWallet(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovWallet(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovWallet(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BalanceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Cash != 0 {
		n += 9
	}
	if m.Used != 0 {
		n += 9
	}
	if m.IsDefault {
		n += 2
	}
	if m.AmountKind != 0 {
		n += 1 + sovWallet(uint64(m.AmountKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.Cash != 0 {
		n += 9
	}
	if m.AmountKind != 0 {
		n += 1 + sovWallet(uint64(m.AmountKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchTradeListArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovWallet(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovWallet(uint64(m.Limit))
	}
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if len(m.Types) > 0 {
		l = 0
		for _, e := range m.Types {
			l += sovWallet(uint64(e))
		}
		n += 1 + sovWallet(uint64(l)) + l
	}
	l = len(m.StartTime)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	l = len(m.EndTime)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.HasMore {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchTradeListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovWallet(uint64(m.Total))
	}
	if m.Page != 0 {
		n += 1 + sovWallet(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovWallet(uint64(m.Limit))
	}
	if m.HasMore {
		n += 2
	}
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovWallet(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TradeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovWallet(uint64(m.ID))
	}
	l = len(m.NO)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovWallet(uint64(m.UID))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovWallet(uint64(l))
	}
	if m.BeforeCash != 0 {
		n += 9
	}
	if m.AfterCash != 0 {
		n += 9
	}
	if m.ChangeCash != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovWallet(uint64(m.Type))
	}
	if m.Status != 0 {
		n += 1 + sovWallet(uint64(m.Status))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovWallet(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovWallet(uint64(m.UpdatedAt))
	}
	if m.BetCash != 0 {
		n += 9
	}
	l = len(m.UserCode)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	l = len(m.NickName)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	l = len(m.ChannelCode)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 2 + l + sovWallet(uint64(l))
	}
	if m.AmountKind != 0 {
		n += 2 + sovWallet(uint64(m.AmountKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovWallet(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWallet(x uint64) (n int) {
	return sovWallet(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InitWalletArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitWalletArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitWalletArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.InitCash = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitWalletReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitWalletReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitWalletReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDefaultCurrencyArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDefaultCurrencyArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDefaultCurrencyArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDefaultCurrencyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDefaultCurrencyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDefaultCurrencyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrBalanceArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrBalanceArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrBalanceArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cash = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taxation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Taxation = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BetAmount = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rebate = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCurrencyID", wireType)
			}
			m.PlayCurrencyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayCurrencyID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PlayCash = float64(math.Float64frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserControlKind", wireType)
			}
			m.UserControlKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserControlKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncrBalanceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncrBalanceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncrBalanceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &BalanceInfo{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &ChangeInfo{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecrBalanceArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecrBalanceArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecrBalanceArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cash = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taxation", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Taxation = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetAmount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BetAmount = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rebate = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCurrencyID", wireType)
			}
			m.PlayCurrencyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayCurrencyID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.PlayCash = float64(math.Float64frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserControlKind", wireType)
			}
			m.UserControlKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserControlKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecrBalanceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecrBalanceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecrBalanceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &BalanceInfo{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &ChangeInfo{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreezeBalanceArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreezeBalanceArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreezeBalanceArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cash = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Amount = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rebate = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FreezeBalanceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FreezeBalanceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FreezeBalanceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &BalanceInfo{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &ChangeInfo{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTradeArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTradeArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTradeArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTradeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTradeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTradeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &BalanceInfo{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Change", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Change == nil {
				m.Change = &ChangeInfo{}
			}
			if err := m.Change.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteTradeArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteTradeArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteTradeArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeNO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradeNO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteTradeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteTradeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteTradeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBalanceArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBalanceArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBalanceArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBalanceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBalanceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBalanceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = make(map[int32]*BalanceInfo)
			}
			var mapkey int32
			var mapvalue *BalanceInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWallet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthWallet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BalanceInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWallet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWallet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Balance[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBalancesArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBalancesArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBalancesArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBalanceMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBalanceMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBalanceMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = make(map[int32]*BalanceInfo)
			}
			var mapkey int32
			var mapvalue *BalanceInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWallet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthWallet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BalanceInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWallet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWallet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Balance[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchBalancesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchBalancesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchBalancesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[string]*FetchBalanceMap)
			}
			var mapkey string
			var mapvalue *FetchBalanceMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthWallet
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthWallet
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthWallet
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthWallet
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FetchBalanceMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipWallet(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthWallet
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BalanceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BalanceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BalanceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cash = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Used = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDefault", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDefault = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Cash = float64(math.Float64frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchTradeListArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchTradeListArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchTradeListArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Types = append(m.Types, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowWallet
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthWallet
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthWallet
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Types) == 0 {
					m.Types = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowWallet
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Types = append(m.Types, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Types", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchTradeListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchTradeListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchTradeListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &TradeInfo{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NO", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NO = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BeforeCash = float64(math.Float64frombits(v))
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AfterCash = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ChangeCash = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BetCash", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.BetCash = float64(math.Float64frombits(v))
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWallet
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWallet
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountKind", wireType)
			}
			m.AmountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AmountKind |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWallet(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthWallet
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWallet(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWallet
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWallet
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWallet
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWallet
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWallet
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWallet        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWallet          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWallet = fmt.Errorf("proto: unexpected end of group")
)
